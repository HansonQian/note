# 分布式事务存在的问题

事务是一组单元化的操作，这组操作可以保证要么全部成功，否则全部失败或者只要有一个失败的操作，就会把其他已经成功的操作回滚，来保证数据的完整性。

分布式事务的产生就是为了能够解决分布式环境下数据的一致性问题，单一数据库可以通过ACID来保证自身的事务处理，在分布式环境下，涉及的就是不同的服务不同数据库，单一的事务处理已经满足不了需求。

随着业务的发展，数据量的增加，数据库往往会做分库分表，那就会存在同时操作两个不同库中表的情况。在这种情况下想要保证数据的一致性那就必须用到分布式事务，不然A库操作成功，B库操作失败，数据就会不一致。

除了数据库本身的拆分会需要分布式事务来解决数据的一致性，还有就是微服务架构下，系统被拆分成n个服务，每个服务都有自己独立的数据库，也会存在同时操作不同服务的数据的情况，因此也需要一套机制来保证数据的一致性。

# 分布式事务的解决方案

## 两阶段提交

二阶段提交（`Two-phase Commit`）是指在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(`Algoruthm`)。

通常，二阶段提交也被称为是一种协议，在嗯不是系统中，每个阶段虽然可以知晓自己的操作是成功还是失败，却无法知道其他节点操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个座位协调组的组件来统一掌控所有节点（称作参与者）的操作结果并最终提示这些节点是否要把操作结果进行真正的提交（比较将更新后的数据写入磁盘等）。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是要提交操作还是中止操作。

## TCC补偿机制

TCC（`Try-Confirm-Cancel`）是分布式事务中比较常用的解决方案之一，通过TCC的名称可以知道分别对应`Try`、`Confirm`和`Cancel`三种操作，这三种操作的业务含义如下：

- Try：预留业务资源
- Confirm：确认执行业务操作
- Cancel：取消执行业务操作

在一个跨服务的业务操作中，首先通过Try锁定服务中的业务资源进行资源预留，只有资源预留成功了，后续的操作常年正常进行。Confirm操作是在Try之后进行的操作，对Try阶段锁定的资源进行业务操作。Cancel则是在所有操作失败时用于回滚，TCC的操作都需要业务方提供对应的功能，在开发成本上比较高。

常用的TCC框架：

- [spring-cloud-rest-tcc](https://github.com/prontera/spring-cloud-rest-tcc)
- [tcc-transaction](https://github.com/changmingxie/tcc-transaction	)
- [EasyTransaction](https://github.com/QNJR-GROUP/EasyTransaction)
- [ByteTCC](https://github.com/liuyangming/ByteTCC	)

## 最终一致性

最终一致性是比较常用的一种方式，跟TCC方式比起来成本也较低，通过结合消息队列来实现异步处理，由于消息队列不支持事务，所以需要我们自己编写一些代码结合消息队列来实现。

### 普通消息

![普通的消息处理流程](https://github.com/HansonQian/note/blob/master/imgs/%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg?raw=true)

- 1）、消息生产者(参与者)发送消息
- 2）、MQ收到消息，将消息进行持久化，在存储中新增一条记录
- 3）、返回确认字符（ACK）给消费者
- 4）、MQ推送消息给对应的消费者，然后等待消费者返回的ACK
- 5）、如果消息消费者在指定时间内成功返回ACK，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤
- 6）、MQ删除消息

#### 普通消息处理流程存在一致性问题

以创建订单为例，订单系统先创建订单（本地事务），再发送消息给下游系统处理。如果订单创建成功，然而消息没有发送出去，那么会导致下游的所有系统无法感知到订单已经创建这件事，会出现脏数据。

```java
public void processOrder(){
    //订单业务
    orderService.process();
    //发送订单处理成功消息
    sendMsg();
}
```

如果先发送订单消息，再创建订单；那么就有可能消息发送成功，但是在订单创建的时候却失败了，此时下游系统却认为这个订单已经创建，也会出现脏数据。

```java
public void processOrder(){
    //发送订单处理成功消息
    sendMsg();
    //订单业务
    orderService.process();
}
```

##### 错误想法

是否将消息发送和业务处理放在同一个本地事务中来进行处理，如果业务消息发送失败，那么本地事务就回滚，这样是不是就能解决消息发送的一致性问题呢?

```java
@Transactionnal
public void processOrder() {
    try{
        // 订单处理(业务操作) 
        orderService.process(); 
        // 发送订单处理成功消息(发送消息) 
        sendMsg ();
    }catch(Exception e){
        //事务回滚;
        rollback();
    }
}
```

##### 异常情况分析

| 可能情况                                                     | 一致性 |
| ------------------------------------------------------------ | ------ |
| 订单处理成功，然后突然宕机，事务未提交，消息没有发送出去     | True   |
| 订单处理成功，由于网络原因或者MQ宕机，消息没有发送出去，事务回滚 | True   |
| 订单处理成功，消息发送成功，但是MQ由于其他原因，导致消息存储失败，事务回滚 | True   |
| 订单处理成功，消息存储成功，但是MQ处理超时，从而ACK确认失败，导致发送方本地事务回滚 | False  |

##### 总结

从上面的情况分析，可以看到，使用普通消息的处理方式，无论如何，都无法保证业务处理与消息发送两边的一致性，其根本的原因就在于：**远程调用，结果最终可能为成功、失败、超时；而对于超时的情况，处理方最终的结果可能是成功，也可能是失败，调用方是无法知晓的。** 



### 事务消息

由于传统的处理方式无法解决`消息生成者本地事务处理成功`与`消息发送成功`两者的一致性问题，因此事务消息就诞生了，**它实现了消息生成者本地事务与消息发送的原子性，保证了消息生成者本地事务处理成功与消息发送成功的最终一致性问题。**

#### 事务消息处理流程

![事务消息处理流程](https://github.com/HansonQian/note/blob/master/imgs/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg?raw=true)

- 1）、事务消息与普通消息的区别就在于消息生产环节，生产者首先预发送一条消息到MQ(这也被称为发送half消息)
- 2）、MQ接受到消息后，先进行持久化，则存储中会新增一条状态为`待发送`的消息
- 3）、然后返回ACK给消息生产者，此时MQ不会触发消息推送事件
- 4）、生产者预发送消息成功后，执行本地事务
- 5）、执行本地事务，执行完成后，发送执行结果给MQ
- 6）、MQ会根据结果删除或者更新消息状态为`可发送`
- 7）、如果消息状态更新为`可发送`，则MQ会push消息给消费者，后面消息的消费和普通消息是一样的

**注意点**：由于MQ通常都会保证消息能够投递成功，因此，如果业务没有及时返回ACK结果，那么就有可能造成MQ的重复消息投递问题。**因此，对于消息最终一致性的方案，消息的消费者必须要对消息的消费支持幂等，不能造成同一条消息的重复消费的情况。**

#### 事务消息异常情况分析

| 情况                                                         | 一致性 | 异常处理                                                     |
| ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| 消息未存储，业务操作未执行                                   | True   | 无                                                           |
| 存储`待发送`消息成功，但是ACK失败，导致业务未执行(可能是MQ处理超时、网络抖动等原因) | False  | MQ确认业务操作结果，处理消息(删除消息)                       |
| 存储`待发送`消息成功，ACK成功，业务执行(可能成功也可能失败)，但是MQ没有收到生产者业务处理的最终结果 | False  | MQ确认业务操作结果，处理消息(根据就业务处理结果，更新消息状态，如果业务执行成功，则投递消息，失败则删除消息) |
| 业务处理成功，并且发送结果给MQ，但是MQ更新消息失败，导致消息状态依旧为`待发送` | False  | 同上                                                         |

#### 支持事务消息的MQ

主流的MQ，有`ActiveMQ`、`RabbitMQ`、`Kafka`、`RocketMQ`等，只有`RocketMQ`支持事务消息。

事务消息存在的异常情况：MQ存储了`待发送`的消息，但是MQ无法感知到上游处理的最终结果。

对于`RocketMQ`而言，它的解决方案非常的简单，就是其内部实现会有一个定时任务，去轮训状态为`待发送`的消息，然后给producer发送check请求，而producer必须实现一个check监听器，监听器的内容通常就是去检查与之对应的本地事务是否成功(一般就是查询DB)，如果成功了，则MQ会将消息设置为`可发送`，否则就删除消息。

#### 常见问题

- 问：如果预发送消息失败，是不是业务就不执行了？

  答：是的，对于基于消息最终一致性的方案，一般都会强依赖这步，如果这个步骤无法得到保证，那么最终也 就不可能做到最终一致性了。

- 问：为什么要增加一个消息`预发送`机制，增加两次发布出去消息的重试机制，为什么不在业务成功之后，发送失败的话使用一次重试机制？

  答：如果业务执行成功，再去发消息，此时如果还没来得及发消息，业务系统就已经宕机了，系统重启后，根本没有记录之前是否发送过消息，这样就会导致业务执行成功，消息最终没发出去的情况。

- 如果consumer消费失败，是否需要producer做回滚呢？

  答：这里的事务消息，producer不会因为consumer消费失败而做回滚，采用事务消息的应用，其所追求的是**高可用**和**最终一致性**，消息消费失败的话，MQ自己会负责重推消息，直到消费成功。因此，事务消息是针对生产端而言的，而消费端，消费端的一致性是通过MQ的重试机制来完成的。

- 如果consumer端因为**业务异常**而导致回滚，那么岂不是两边最终无法保证一致性?

  答：基于消息的最终一致性方案必须保证消费端在**业务上的操作没障碍**，它只允许系统异常的失败，不允许业务上的失败，比如在你业务上抛出个`NPE`之类的问题，导致你消费端执行事务失败，那就很难做到一致了。

### 本地消息

> 由于并非所有的MQ都支持事务消息，假如我们不选择`RocketMQ`来作为系统的MQ，是否能够做到消息的最终一致性呢？答案是可以的。

![本地消息](https://github.com/HansonQian/note/blob/master/imgs/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF.png?raw=true)

`基于本地消息的最终一致性`方案的**最核心做法就是在执行业务操作的时候，记录一条消息数据到DB，并且消息数据的记录与业务数据的记录必须在同一个事务内完成，这是该方案的前提核心保障**。

在记录完成后消息数据后，后面我们就可以通过一个定时任务到DB中去轮训状态为`待发送`的消息，然后将消息投递给MQ。这个过程中可能存在消息投递失败的可能，此时就依靠`重试机制`来保证，直到成功收到MQ的ACK确认之后，再将消息状态更新或者消息清除；而后面消息的消费失败的话，则依赖MQ本身的重试来完成，其最后做到两边系统数据的最终一致性。`基于本地消息服务`的方案虽然可以做到消息的最终一致性，但是它有一个比较严重的弊端，每个业务系统在使用该方案时，都需要在对应的业务库创建一张消息表来存储消息。针对这个问题，可以将该功能单独提取出来，做成一个消息服务来统一处理。

### 独立消息

> 优化本地消息方案

![独立消息](https://github.com/HansonQian/note/blob/master/imgs/%E7%8B%AC%E7%AB%8B%E6%B6%88%E6%81%AF.png?raw=true)

`独立消息服务最终一致性`与`本地消息服务最终一致性`最大的差异就在于将消息的存储单独地做成了一个RPC的服务，这个过程其实就是模拟了事务消息的消息预发送过程，如果预发送消息失败，那么生产者业务就不会去执行，因此对于生产者的业务而言，它是强依赖于该消息服务的。不过好在独立消息服务支持水平扩容，因此只要部署多台，做成HA的集群模式，就能够保证其可靠性。在消息服务中，还有一个单独地定时任务，它会定期轮训长时间处于`待发送`状态的消息，通过一个**check补偿机制**来确认该消息对应的业务是否成功，如果对应的业务处理成功，则将消息修改为`可发送`，然后将其投递给MQ；如果业务处理失败，则将对应的消息更新或者删除即可。因此在使用该方案时，消息生产者必须同时实现一个check服务，来供消息服务做消息的确认。对于消息的消费，该方案与上面的处理是一样，都是通过MQ自身的重发机制来保证消息被消费。

