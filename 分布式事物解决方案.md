# 分布式事务存在的问题

事务是一组单元化的操作，这组操作可以保证要么全部成功，否则全部失败或者只要有一个失败的操作，就会把其他已经成功的操作回滚，来保证数据的完整性。

分布式事务的产生就是为了能够解决分布式环境下数据的一致性问题，单一数据库可以通过ACID来保证自身的事务处理，在分布式环境下，涉及的就是不同的服务不同数据库，单一的事务处理已经满足不了需求。

随着业务的发展，数据量的增加，数据库往往会做分库分表，那就会存在同时操作两个不同库中表的情况。在这种情况下想要保证数据的一致性那就必须用到分布式事务，不然A库操作成功，B库操作失败，数据就会不一致。

除了数据库本身的拆分会需要分布式事务来解决数据的一致性，还有就是微服务架构下，系统被拆分成n个服务，每个服务都有自己独立的数据库，也会存在同时操作不同服务的数据的情况，因此也需要一套机制来保证数据的一致性。

# 分布式事务的解决方案

## 两阶段提交

二阶段提交（`Two-phase Commit`）是指在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(`Algoruthm`)。

通常，二阶段提交也被称为是一种协议，在嗯不是系统中，每个阶段虽然可以知晓自己的操作是成功还是失败，却无法知道其他节点操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个座位协调组的组件来统一掌控所有节点（称作参与者）的操作结果并最终提示这些节点是否要把操作结果进行真正的提交（比较将更新后的数据写入磁盘等）。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是要提交操作还是中止操作。

## TCC补偿机制

TCC（`Try-Confirm-Cancel`）是分布式事务中比较常用的解决方案之一，通过TCC的名称可以知道分别对应`Try`、`Confirm`和`Cancel`三种操作，这三种操作的业务含义如下：

- Try：预留业务资源
- Confirm：确认执行业务操作
- Cancel：取消执行业务操作

在一个跨服务的业务操作中，首先通过Try锁定服务中的业务资源进行资源预留，只有资源预留成功了，后续的操作常年正常进行。Confirm操作是在Try之后进行的操作，对Try阶段锁定的资源进行业务操作。Cancel则是在所有操作失败时用于回滚，TCC的操作都需要业务方提供对应的功能，在开发成本上比较高。

常用的TCC框架：

- [spring-cloud-rest-tcc](https://github.com/prontera/spring-cloud-rest-tcc)
- [tcc-transaction](https://github.com/changmingxie/tcc-transaction	)
- [EasyTransaction](https://github.com/QNJR-GROUP/EasyTransaction)
- [ByteTCC](https://github.com/liuyangming/ByteTCC	)

## 最终一致性

最终一致性是比较常用的一种方式，跟TCC方式比起来成本也较低，通过结合消息队列来实现异步处理，由于消息队列不支持事务，所以需要我们自己编写一些代码结合消息队列来实现。

### 普通消息的处理流程

![普通的消息处理流程](https://github.com/HansonQian/note/blob/master/imgs/%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg?raw=true)

- 1）、消息生产者(参与者)发送消息
- 2）、MQ收到消息，将消息进行持久化，在存储中新增一条记录
- 3）、返回确认字符（ACK）给消费者
- 4）、MQ推送消息给对应的消费者，然后等待消费者返回的ACK
- 5）、如果消息消费者在指定时间内成功返回ACK，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤
- 6）、MQ删除消息

#### 普通消息处理流程存在一致性问题

以创建订单为例，订单系统先创建订单（本地事务），再发送消息给下游系统处理。如果订单创建成功，然而消息没有发送出去，那么会导致下游的所有系统无法感知到订单已经创建这件事，会出现脏数据。

```java
public void processOrder(){
    //订单业务
    orderService.process();
    //发送订单处理成功消息
    sendMsg();
}
```

如果先发送订单消息，再创建订单；那么就有可能消息发送成功，但是在订单创建的时候却失败了，此时下游系统却认为这个订单已经创建，也会出现脏数据。

```java
public void processOrder(){
    //发送订单处理成功消息
    sendMsg();
    //订单业务
    orderService.process();
}
```

##### 错误想法

是否将消息发送和业务处理放在同一个本地事务中来进行处理，如果业务消息发送失败，那么本地事务就回滚，这样是不是就能解决消息发送的一致性问题呢?

```java
@Transactionnal
public void processOrder() {
    try{
        // 订单处理(业务操作) 
        orderService.process(); 
        // 发送订单处理成功消息(发送消息) 
        sendMsg ();
    }catch(Exception e){
        //事务回滚;
        rollback();
    }
}
```

##### 情况分析

| 可能情况                                                     | 一致性 |
| ------------------------------------------------------------ | ------ |
| 订单处理成功，然后突然宕机，事务未提交，消息没有发送出去     | True   |
| 订单处理成功，由于网络原因或者MQ宕机，消息没有发送出去，事务回滚 | True   |
| 订单处理成功，消息发送成功，但是MQ由于其他原因，导致消息存储失败，事务回滚 | True   |
| 订单处理成功，消息存储成功，但是MQ处理超时，从而ACK确认失败，导致发送方本地事务回滚 | False  |

##### 总结

从上面的情况分析，可以看到，使用普通消息的处理方式，无论如何，都无法保证业务处理与消息发送两边的一致性，其根本的原因就在于：**远程调用，结果最终可能为成功、失败、超时；而对于超时的情况，处理方最终的结果可能是成功，也可能是失败，调用方是无法知晓的。** 



### 事务消息

由于传统的处理方式无法解决`消息生成者本地事务处理成功`与`消息发送成功`两者的一致性问题，因此事务消息就诞生了，**它实现了消息生成者本地事务与消息发送的原子性，保证了消息生成者本地事务处理成功与消息发送成功的最终一致性问题。**

#### 事务消息处理流程

![事务消息处理流程](https://github.com/HansonQian/note/blob/master/imgs/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg?raw=true)

