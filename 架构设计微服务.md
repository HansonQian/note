## 1、微服务介绍

### 1.1、微服务是如何演变过来的

#### 1.1.1、开发一个单体应用

假设你正准备开发一款与`Uber`和`Hailo`竞争的出租车调度软件，经过初步会议和需求分析，你可能会手动或者使用基于`Spring Boot`、`Play`或者`Maven`的生成器开始这个新项目，它的六边形架构是模块化的 ，架构图如下：

![Monolithic architecture.png](https://github.com/HansonQian/note/blob/master/imgs/ms-uber.png?raw=true)

应用核心是业务逻辑，由定义服务、域对象和事件的模块完成。围绕着核心的是与外界打交道的适配器。适配器包括数据库访问组件、生产和处理消息的消息组件，以及提供`API`或者`UI`访问支持的`web`模块等。

尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。具体的格式依赖于应用语言和框架。例如，许多Java应用会被打包为`WAR`格式，部署在`Tomcat`或者`Jetty`上。

#### 1.1.2、单体式应用的不足

在做一个新项目的时候，一开始项目大多数都很小，都是「 单体应用 」，这是很常见的做法。

在项目规模小的时候，这种方式开发效率和运维效率都最高，项目规模逐渐变大后，单体应用就会存在以下问题：

- 复杂性高
  - 项目模块非常的多、模块边界模糊、依赖关系模糊、代码质量参差不齐
- 技术债务
  - 随着时间推移人员迭代、需求变更，会逐渐形成应用程序的技术债务
- 部署频率
  - 代码量的增加，构建和部署的时间也会增加。每次功能的变更或者缺陷修复都可能导致需要重新部署整个应用。全量部署的方式耗时长、风险大、影响范围广，使得整个应用上线部署效率低下
- 可靠性差
  - 某个应用的Bug（例如:死循环、OOM等），导致整个应用宕机
- 扩展能力受限
  - 单一应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩
- 阻碍技术创新
  - 单体应用一般都是使用统一的技术平台或者方案来解决所有的问题，团队中的所有人都必须使用相同的编程语言和框架，要想引入新的技术框架或者新的技术平台会非常的困难

#### 1.1.3、如何解决

通过采用微处理结构模式解决上述问题。他的思路不是开发一个巨大的单体式的应用，而是将应用分解为小的、互相连接的「 微服务 」。

### 1.2、什么是微服务

- 微服务是由[Martin fowler](https://martinfowler.com/articles/microservices.html)提出的，它是用来描述将软件应用程序设计为独立部署的服务的一种特殊方式。微服务本身没有一个严格的定义。
- [Martin fowler](https://martinfowler.com/articles/microservices.html)在他的[博客](https://martinfowler.com/microservices/)对微服务的描述

  ```reStructuredText
  In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies
  ```

  ```reStructuredText
  简而言之，微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统的。其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API这样轻量的机制来相互通信。这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术
  ```

### 1.3、微服务架构是怎么样的

#### 1.3.1、单体应用拆分

一个「 微服务 」一般完成某个特定的功能，比如下单管理、客户管理等等。每一个「 微服务 」都是微型六角形应用，都有自己的业务逻辑和适配器。一些「 微服务 」还会发布`API`给其它「 微服务 」和应用客户端使用。其它「 微服务 」完成一个`Web UI`，运行时，每一个实例可能是一个云`VM`或者是`Docker`容器。上述的单体应用示例使用「 微服务 」会拆分成这样：

![Microservcice](https://github.com/HansonQian/note/blob/master/imgs/Monolithic%20architecture.png?raw=true)

#### 1.3.2、微服务的优点

- 易于开发和维护
  - 一个微服务只会关注一个特定的业务功能，所以它业务清晰，代码量较少。开发和维护单个微服务相对简单。而整个应用是由若干个微服务构建而成，所以整个应用会被维持在一个可控状态
- 单个微服务启动快
  - 单个微服务代码量较少，所以启动比较快
- 局部修改容易部署
  - 单体应用只要有修改，就得重新部署整个应用。微服务解决了这个问题，一般来说修改某个微服务只需要重启某个微服务
- 技术栈不受限
  - 在微服务架构中，可以结合业务及团队的特点，合理选择技术栈。例如某些微服务可以选择`MySQL`。某些微服务有图形计算的需求可以选择`Neo4J`。甚至根据需要，部分微服务使用`Java`开发，部分使用`Node JS`开发
- 按需伸缩
  - 可根据需求，实现细粒度的扩展。例如系统中的某个微服务遇到了瓶颈，可以结合业务特点，增加内存，升级CPU或者是增加节点

#### 1.3.3、微服务基础组件

要保证一个基于「 微服务 」架构实现的系统正常运行起来，最少需要以下几个组件:

- **服务注册**
  - 部署一个服务节点，如何让调用者知道？删除一个服务节点，如何也让调用者知道？通过**服务注册**组件来实现，服务提供者将自身的信息登记到服务注册中心，服务调用者调用服务需要先到服务注册中心查询可用的服务节点
- **服务网关**
  - 提供给外部系统调用的是统一网关。主要做授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等
- **配置中心**
  - 微服务的配置中心是用来统一管理所有微服务节点的配置信息的。因为同一个程序可能要适用于多个环境，所以在微服务实践中要尽量做到程序与配置分离，将配置进行集中管理。包括微服务节点信息、程序运行时配置、变量配置、数据源配置、日志配置、版本配置等。
- **服务框架**
  - 是指用来规范各个微服务节点之间通信标准的。服务间通信采用什么协议、数据是如何传输的、数据格式是什么样的。有了这个统一的“服务框架”就能保证各个微服务节点之间高效率的协同。
- **服务监控**
  - 微服务运行起来之后，为了能够监控节点的健康情况，保障节点的高可行，需要对各个服务节点进行收集数据指标、然后对数据进行实时处理和分析，形成监控报表和预警。
- **服务追踪**
  - 一旦使用了微服务架构，那么当有请求过来时，就会经过多个微服务节点的处理，形成了一个调用链。为了进行问题追踪和故障的定位，需要对请求的完整调用链进行记录。
    - 这里的服务追踪与上面的服务监控是不同维度的，一个是全局的，一个是微观的，发挥的作用也不一样。
- **服务治理**
  - 是指需要通过准备一些策略和方案，来保障整个微服务架构在生产环境遇到极端情况下也能正常提供服务的措施。比如 熔断、限流、隔离等等。

### 1.4、微服务面临的挑战

- 运维成本高
  - 更多的微服务意味着更多的运维投入。在单体架构中，只需要保证一个应用正常运行。而在微服务，需要保证几十甚至几百个微服务正常运行与协助，这给运维带来了很大的挑战（需要具备`DevOps`）
- 分布式固有的复杂性
  - 分布式固有的复杂性：使用微服务构建的是分布式系统，对于一个分布式系统，系统容错，网络延迟，分布式事务都会带来巨大的挑战（`CAP`）
- 接口调整成本高
  - 微服务之间通过接口进行通信。如果修改某个微服务API，可能所有使用了该接口的微服务都需要调整
- 重复劳动
  - 很多微服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个微服务都会开发这一功能，从而导致代码重复

## 2、微服务架构组件

### 2.1、服务注册

#### 2.1.1、为什么需要服务注册

【服务消费者】需要调用【服务提供者】的`API`来获得服务。当【服务提供者】的节点有新增或者剔除时，应该及时让【服务消费者】知晓。而大规模、集群的应用节点会很多，节点变化也很频繁，通过手动去维护这些节点的状态是不太现实的，因此才会需要服务注册中心组件来实现。

#### 2.1.2、服务注册原理

![服务注册原理](https://github.com/HansonQian/note/blob/master/imgs/ServiceRegister.png?raw=true)

【服务提供者】需要将自身的服务信息注册到【服务注册中心】，【服务消费者】到【服务注册中心】检索服务，并将检索到的服务缓存在本地，对检索到的服务进行调用。

- **服务提供者**向**服务注册中心**注册

  注册分为两种分别是：自己注册和第三方注册

  - **自己注册**

    ![SELF-REGISTRATION](https://github.com/HansonQian/note/blob/master/imgs/SELF-REGISTRATION.jpg?raw=true)

    自己注册就是在服务启动的时候，自己去服务注册中心登记注册，将自身的服务信息、状态传递到服务注册中心。这种方式整体结构比较简单，对于注册中心比较省事，但是对于服务节点来说，每一个节点都需要包含一段注册的逻辑，从整体来看，架构不是完美的。

  - **第三方注册**

    ![THIRD-PARTY-REGISTRATION](https://github.com/HansonQian/note/blob/master/imgs/THIRD-PARTY-REGISTRATION.jpg?raw=true)

    第三方注册是指有一个`Service Manager`（服务管理器），它会去管理所有的服务和进程信息，以轮询的方式（或者其他方式）去检索哪些服务正在运行，会将这些服务实例自动更新到服务注册中心。

- **服务消费者**向**服务注册中心**检索和调用服务（服务发现）

  服务调用和查询也分为两种分别是：客户端模式和代理模式

  - **客户端模式**

    ![CLIENT-SIDE DISCOVERY](https://github.com/HansonQian/note/blob/master/imgs/CLIENT-SIDE-DISCOVERY.jpg?raw=true)

    `Client`(服务消费者)向`Service Registry`（服务注册中心）检索到自己需要调用的服务地址后，`Client`会根据地址去访问`Microservice`（微服务）（`API Gateway`是可选项，如果有`API Gateway`，那么它起到负载均衡作用；如果没有，那么需要`Client`自己写负载均衡策略）

  - **代理模式**

    ![SERVER-SIDE-DISCOVERY](https://github.com/HansonQian/note/blob/master/imgs/SERVER-SIDE-DISCOVERY.PNG?raw=true)

    `Client`（服务消费者）与`Service Registry`（服务注册中心）中间有`API Gateway`组件。`Client`只管找`API Gateway`访问。至于`API Gateway`怎么查询服务地址，已经访问服务地址的动作都由`API Gateway`代劳，最后`API Gateway`将服务结果返回给`Client`。

    这种模式，看起来“服务消费者”省事了，但是`API Gateway`模块却复杂了，因为`API Gateway`就是整个系统的一个非常核心关键节点了，不仅需要保障自己的稳定性和性能，而且还需要处理一些负载均衡的逻辑。

#### 2.1.3、服务注册实践

虽然可以根据原理研发一套服务注册中心，如果没有特殊需求的话，还是不用重复造轮子。毕竟市面上很多成熟的服务注册中心解决方案，并且都经历过实际场景验证，可以直接拿过来使用。

- **Eureka**：` [juˈriːkə] `

  Eureka(https://github.com/Netflix/eureka )是由`Netflix`开源，其架构如下图:

  ![Eureka高可用架构](https://github.com/Netflix/eureka/raw/master/images/eureka_architecture.png)

  - 从图中可以看到，我们的服务（图中Application Clinet与Application Service）要使用Eureka就需要集成它的SDK（图中Eureka Client）。图中的Eureka部署在了三个异地机房，也就是说Eureka是支持多中心部署的。

  - 服务提供者（Application Service）通过Eureka Client实现服务的注册、更新和注销等。服务消费者（Application Clinet）通过Eureka Client实现服务的查询和调用。

  - Eureka支持了与Spring Cloud的集成，所以使用起来也非常方便，目前属于比较流行的方案。

- **Consul**：` [ˈkɒnsl]`

  Consul是另外一个非常流行的开源组件，如下图:

  ![Consul](https://github.com/HansonQian/note/blob/master/imgs/CONSUL.jpg?raw=true)

  - Consul是在服务外进行完成一系列动作的，也就是说并不需要服务节点去依赖它的SDK，没有侵入性，所以跨语言的解决能力更强一些。它一般是在服务节点外通过一些探针的方法去检查应用是否存活，是否需要注册或注销。
  - Consul也支持Spring Cloud集成，所以使用起来也很方便，也属于比较流行的方案。

- **Etcd、Zookeeper**

  这两个也有一些公司基于它们来实现服务注册，也集成了Spring Cloud，不过不算非常广泛。

### 2.2、负载均衡

### 2.3、网关路由

### 2.4、配置中心

### 2.5、服务监控

### 2.6、服务追踪

### 2.7、服务治理

